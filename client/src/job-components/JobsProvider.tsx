import React, { useCallback, useContext, useEffect, useReducer } from 'react';
import PropTypes from 'prop-types';
import { getLogger } from '../core';
import { JobProps } from './JobProps';
import {createJob, getJobs, updateJob} from './jobsCommunicationApi';
import {AuthContext} from "../auth";
import {useNetwork} from "../network/useNetwork";
import {JOBS_WS_PATH} from "../core/constants";
import {newWebSocket} from "../core/web-socket";

const log = getLogger('JobsProvider');

type SaveJobFn = (job: JobProps) => Promise<any>;
type FetchJobsFn = () => Promise<any>;

export interface JobsState {
  jobs?: JobProps[],
  fetching: boolean,
  fetchingError?: Error | null,
  saving: boolean,
  savingError?: Error | null,
  saveJob?: SaveJobFn,
  fetchMoreJobs?: FetchJobsFn,
  temporaryId?: number,
  locallySavedJobs?: JobProps[]
}

interface ActionProps {
  type: string,
  payload?: any,
}

const initialState: JobsState = {
  fetching: false,
  saving: false
};

const FETCH_JOBS_STARTED = 'FETCH_JOBS_STARTED';
const FETCH_JOBS_SUCCEEDED = 'FETCH_JOBS_SUCCEEDED';
const FETCH_MORE_JOBS_SUCCEEDED = 'FETCH_MORE_JOBS_SUCCEEDED';
const FETCH_JOBS_FAILED = 'FETCH_JOBS_FAILED';
const SAVE_JOB_STARTED = 'SAVE_JOB_STARTED';
const SAVE_JOB_SUCCEEDED = 'SAVE_JOB_SUCCEEDED';
const SAVE_JOB_FAILED = 'SAVE_JOB_FAILED';
const CHANGE_JOBS = 'CHANGE_JOBS';
const CHANGE_LOCALLY_SAVED_JOBS = 'CHANGE_LOCALLY_SAVED_JOBS';
const RESET_LOCAL_STORAGE = 'RESET_LOCAL_STORAGE';

const TEMPORARY_ID_PREFIX = 'TEMPORARY_ID_PREFIX';

const reducer: (state: JobsState, action: ActionProps) => JobsState =
  (state, { type, payload }) => {
    switch(type) {
      case FETCH_JOBS_STARTED:
        return { ...state, fetching: true, fetchingError: null };
      case FETCH_JOBS_SUCCEEDED:
        return { ...state, jobs: payload.jobs, fetching: false };
      case FETCH_MORE_JOBS_SUCCEEDED:
        return { ...state, jobs: [...(state.jobs || []), ...(payload.jobs || [])], fetching: false }; // copy new fetched applications to applications state
      case FETCH_JOBS_FAILED:
        return { ...state, fetchingError: payload.error, fetching: false };
      case SAVE_JOB_STARTED:
        return { ...state, savingError: null, saving: true };
      case SAVE_JOB_SUCCEEDED:
        const jobs = [...(state.jobs || [])];
        const locallySavedJobs = [...(state.locallySavedJobs || [])]

        const job = payload.job;
        const index = jobs.findIndex(j => j._id === job._id);

        if (index === -1) {
          jobs.splice(0, 0, job);
        } else {
          jobs[index] = job;
        }

        if(payload.networkStatus && !payload.networkStatus.connected) {
          const index = locallySavedJobs.findIndex(j => j._id === job._id);
          if (index === -1) {
            locallySavedJobs.splice(0, 0, job);
          } else {
            locallySavedJobs[index] = job;
          }
        }
        return { ...state, jobs: jobs, saving: false, temporaryId: payload.newTemporaryId, locallySavedJobs: locallySavedJobs };
      case SAVE_JOB_FAILED:
        return { ...state, savingError: payload.error, saving: false };
      case CHANGE_JOBS:
        return { ...state, jobs: payload.jobs };
      case CHANGE_LOCALLY_SAVED_JOBS:
        return { ...state, locallySavedJobs: payload.jobs };
      case RESET_LOCAL_STORAGE:
        return { ...state, temporaryId: 0, locallySavedJobs: [] }
      default:
        return state;
    }
  };

export const JobsContext = React.createContext<JobsState>(initialState);

interface JobsProviderProps {
  children: PropTypes.ReactNodeLike,
}

export const JobsProvider: React.FC<JobsProviderProps> = ({ children }) => {
  const { token } = useContext(AuthContext);
  const { networkStatus } = useNetwork();
  const [state, dispatch] = useReducer(reducer, initialState);
  const { jobs, fetching, fetchingError, saving, savingError, temporaryId, locallySavedJobs: locallySavedJobs } = state;

  useEffect(getJobsEffect, [token]);
  useEffect(wsEffect, [token]);

  useEffect(() => {
    if(networkStatus.connected) {
      if(locallySavedJobs && locallySavedJobs.length > 0) { // changes have been made while offline, server must be updated
        const newLocallySavedJobs = [...(locallySavedJobs || [])];

        newLocallySavedJobs.forEach(async (job) => { // updating server
          if(job._id === undefined || job._id && job._id.startsWith(TEMPORARY_ID_PREFIX)) {
            delete job._id; // permanent id will be generated by server
            await createJob(token, job);
          } else { // job._id is defined && !job._id.startsWith(TEMPORARY_ID_PREFIX)
            await updateJob(token, job);
          }
        });

        dispatch({type: CHANGE_LOCALLY_SAVED_JOBS, payload: { jobs: newLocallySavedJobs }});

        if(jobs !== undefined) {
          let newJobsList = jobs.filter((job) => { // removing locally added while offline applications (will be generated again by server with new valid and permanent IDs)
            return (job._id !== undefined && !job._id.startsWith(TEMPORARY_ID_PREFIX));
          });
          dispatch({type: CHANGE_JOBS, payload: {jobs: newJobsList}})
        }

        dispatch({type: RESET_LOCAL_STORAGE});
      }
    } else {
      dispatch({type: RESET_LOCAL_STORAGE});
    }
  }, [networkStatus]);

  const saveJob = useCallback<SaveJobFn>(saveJobCallback, [token, networkStatus, temporaryId]);
  const fetchMoreJobs = useCallback<FetchJobsFn>(fetchJobsCallback, [token, jobs]);

  const value = { jobs, fetching, fetchingError, saving, savingError, saveJob, fetchMoreJobs };

  log('returns');

  return (
    <JobsContext.Provider value={value}>
      {children}
    </JobsContext.Provider>
  );

  function getJobsEffect() {
    let canceled = false;
    if (token) {
      fetchJobs();
    }
    return () => {
      canceled = true;
    }

    async function fetchJobs() {
      try {
        log('fetchJobs started');
        dispatch({ type: FETCH_JOBS_STARTED });
        // const numberOfLoadedJobs = state.applications === undefined ? 0 : state.applications.length;
        const jobs = await getJobs(token, 0);
        log('fetchJobs succeeded');
        if (!canceled) {
          dispatch({ type: FETCH_JOBS_SUCCEEDED, payload: { jobs } });
        }
      } catch (error) {
        log('fetchJobs failed', error);
        dispatch({ type: FETCH_JOBS_FAILED, payload: { error } });
      }
    }
  }

  async function fetchJobsCallback() {
    if (token) {
      try {
        log('fetchJobs started');
        const numberOfLoadedJobs = state.jobs === undefined ? 0 : state.jobs.length;
        const jobs = await getJobs(token, numberOfLoadedJobs);
        log('fetchJobs succeeded');
        dispatch({type: FETCH_MORE_JOBS_SUCCEEDED, payload: { jobs }});
        return jobs.length;
      } catch (error) {
        log('fetchJobs failed', error);
        dispatch({type: FETCH_JOBS_FAILED, payload: {error}});
      }
    }
  }

  async function saveJobCallback(job: JobProps) {
    try {
      log('saveApplication started');
      dispatch({ type: SAVE_JOB_STARTED });

      let savedJob;
      let incrementValue = 0;

      if(networkStatus.connected) {
        savedJob = await (job._id ? updateJob(token, job) : createJob(token, job));
      } else {
        savedJob = job;
        if(!job._id) { // undefined
          savedJob._id = TEMPORARY_ID_PREFIX + (temporaryId === undefined ? '' : temporaryId.toString());
          incrementValue = 1;
        }
      }

      log('saveApplication succeeded');
      dispatch({ type: SAVE_JOB_SUCCEEDED, payload: { job: savedJob, newTemporaryId: (temporaryId === undefined ? 0 : temporaryId) + incrementValue, networkStatus: networkStatus } });
    } catch (error) {
      log('saveApplication failed');
      dispatch({ type: SAVE_JOB_FAILED, payload: { error } });
    }
  }

  function wsEffect() {
    let canceled = false;
    log('wsEffect - connecting');
    let closeWebSocket: () => void;
    if (token?.trim()) {
      closeWebSocket = newWebSocket(token, JOBS_WS_PATH, message => {
        if (canceled) {
          return;
        }
        const { type, payload: job } = message;
        log(`ws message, job ${type}`);
        if (type === 'created' || type === 'updated') {
          dispatch({ type: SAVE_JOB_SUCCEEDED, payload: { job } });
        }
        //TODO dispatch action for deletion type
      });
    }
    return () => {
      log('wsEffect - disconnecting');
      canceled = true;
      closeWebSocket?.();
    }
  }
};
